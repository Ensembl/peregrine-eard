>> test

argument passing smoke

5 = call to f1 from f2
6 = call to f2 from p
7 = call to p from top
8 = copy into x at top

5/r0 = a,b
6/r0 = a,b
7/r0 = a,b
7/a0 = a,b
8/r0 = a,b

>> input

function f1() { let a.a = 1; let a.b = 2; *a }
function f2() { f1() }
procedure p(*a) { (a.a,a.b) }
procedure print(a) { 0 }

let *x = p(f2());

print(x.a);
print(x.b);

>> built strip

0:func () {
  test:2 (r1) <- #1 Number(1.0)
  test:2 let a.a
  test:2 (a.a) <- #2 r1
  test:2 (r2) <- #3 Number(2.0)
  test:2 let a.b
  test:2 (a.b) <- #4 r2
  (*a)
}

1:func () {
  ((0#5))
}

2:proc (*a) {
  (a.a,a.b)
}

3:proc (a) {
  (Number(0.0))
}

test:2 define 0
test:3 define 1
test:4 define 2
test:5 define 3
test:7 (*r3) <- (2#7 (1#6))
test:7 let *x
test:7 (*x) <- #8 *r3
test:9 (3#9 x.a)
test:10 (3#10 x.b)

>> unbundle

{
    ([6], Arg(0)): {"a", "b"},
    ([8], Return(0)): {"b", "a"},
    ([6, 5], Return(0)): {"a", "b"},
    ([7], Return(0)): {"b", "a"}
}

>> test

test returns of nested bundles

>> input

procedure print(a) { 0 }

function func1() { 
    let a.a = 0;
    let a.b = 1;
    let a.c = 2;
    *a
}

function func2() { func1() }

procedure p() {
    let a.d = 3;
    (func1(),func2(),*a)
}

let (*x,*y,*z) = p();
let (*m,*n) = (func1(),func2());

print(m.a);
print(m.b);
print(m.c);
print(n.a);
print(x.a);
print(x.c);
print(y.b);
print(y.c);
print(z.d);

>> xunbundle

>> test

test anon regression

>> input

procedure proc1() {
    let a.a = 0;
    (*a,1)
}

let (*b,c) = proc1();

>> xunbundle

>> test

test anon regression2

>> input

procedure print(a) { 0 }

function func1() {
    let a.a = 0;
    *a
}

let *b = func1();
print(b.z);

>> xunbundle
