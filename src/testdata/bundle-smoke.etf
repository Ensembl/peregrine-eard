>> test

regression 2

0 = print
1 = thru [#8]
2 = drain [#10]

>> input

procedure print(a) { 0 }
procedure thru(*a) { *a }
procedure drain(*a) { print(a.c); }

let a.a = 1;
let a.b = 2;
let a.c = 3;
let *a = thru(*a);
drain(*a);

>> built strip

0:proc (a) {
  (Number(0.0))
}

1:proc (*a) {
  (*a)
}

2:proc (*a) {
  test:4 (0#1 a.c)
  ()
}

test:2 define 0
test:3 define 1
test:4 define 2
test:6 (r1) <- #2 Number(1.0)
test:6 let a.a
test:6 (a.a) <- #3 r1
test:7 (r2) <- #4 Number(2.0)
test:7 let a.b
test:7 (a.b) <- #5 r2
test:8 (r3) <- #6 Number(3.0)
test:8 let a.c
test:8 (a.c) <- #7 r3
test:9 (*r4) <- (1#8 *a)
test:9 let *a
test:9 (*a) <- #9 *r4
test:10 (2#10 *a)

>> unbundle trim

8/Arg(0): c
8/Return(0): c
9/Return(0): c
10/Arg(0): c

>> test

regression 1

>> input

procedure print(a) { 0 }
function f(*a) { *a }
let x.a = 0;
let *x = f(*x);
print(x.a);

>> built strip

0:proc (a) {
  (Number(0.0))
}

1:func (*a) {
  (*a)
}

test:2 define 0
test:3 define 1
test:4 (r1) <- #1 Number(0.0)
test:4 let x.a
test:4 (x.a) <- #2 r1
test:5 (*r2) <- #4 (1#3 *x)
test:5 let *x
test:5 (*x) <- #5 *r2
test:6 (0#6 x.a)

>> unbundle trim

4/Return(0): a
4,3/Arg(0): a
4,3/Return(0): a
5/Return(0): a

>> test

argument passing smoke

0 = print
1 = consumes_c
2 = generates_c
3 = p

10 = consumes_c
13 = generates_c
16 = consumes_c
17 = p

>> input

procedure print(a) { let x = a; 0 }
function consumes_c(*a) { print(a.c); 0 }

function generates_c() {
  let z.a = 1;
  let z.b = 2;
  let z.c = 3;
  *z
}

procedure p(*a) { let x = consumes_c(*a); x }

let *x = generates_c();
let y = p(consumes_c(*x));
print(x.a);

>> built strip

0:proc (a) {
  test:2 (r1) <- #1 a
  test:2 let x
  test:2 (x) <- #2 r1
  (Number(0.0))
}

1:func (*a) {
  test:3 (0#3 a.c)
  (Number(0.0))
}

2:func () {
  test:5 (r2) <- #4 Number(1.0)
  test:5 let z.a
  test:5 (z.a) <- #5 r2
  test:5 (r3) <- #6 Number(2.0)
  test:5 let z.b
  test:5 (z.b) <- #7 r3
  test:5 (r4) <- #8 Number(3.0)
  test:5 let z.c
  test:5 (z.c) <- #9 r4
  (*z)
}

3:proc (*a) {
  test:12 (r5) <- #11 (1#10 *a)
  test:12 let x
  test:12 (x) <- #12 r5
  (x)
}

test:2 define 0
test:3 define 1
test:5 define 2
test:12 define 3
test:14 (*r6) <- #14 (2#13)
test:14 let *x
test:14 (*x) <- #15 *r6
test:15 (r7) <- (3#17 (1#16 *x))
test:15 let y
test:15 (y) <- #18 r7
test:16 (0#19 x.a)

>> unbundle trim

14/Return(0): a c
14,13/Return(0): a c
15/Return(0): a c
17/Arg(0): c
17,11,10/Arg(0): c
17,16/Arg(0): c

>> test

argument passing return check smoke

5 = call to f1 from f2
6 = call to f2 from p
7 = call to p from top
8 = copy into x at top

7,6,5/r0 = a,b
7,6/r0 = a,b
7/r0 = a,b
7/a0 = a,b
8/r0 = a,b

>> input

function f1() { let a.a = 1; let a.b = 2; *a }
function f2() { f1() }
procedure p(*a) { (a.a,a.b) }
procedure print(a) { 0 }

let *x = p(f2());

print(x.a);
print(x.b);

>> built strip

0:func () {
  test:2 (r1) <- #1 Number(1.0)
  test:2 let a.a
  test:2 (a.a) <- #2 r1
  test:2 (r2) <- #3 Number(2.0)
  test:2 let a.b
  test:2 (a.b) <- #4 r2
  (*a)
}

1:func () {
  ((0#5))
}

2:proc (*a) {
  (a.a,a.b)
}

3:proc (a) {
  (Number(0.0))
}

test:2 define 0
test:3 define 1
test:4 define 2
test:5 define 3
test:7 (*r3) <- (2#7 (1#6))
test:7 let *x
test:7 (*x) <- #8 *r3
test:9 (3#9 x.a)
test:10 (3#10 x.b)

>> unbundle trim

7/Arg(0): a b
7/Return(0): a b
7,6/Return(0): a b
7,6,5/Return(0): a b
8/Return(0): a b

>> test

test returns of nested bundles

>> input

procedure print(a) { 0 }

function func1() { 
    let a.a = 0;
    let a.b = 1;
    let a.c = 2;
    *a
}

function func2() { func1() }

procedure p() {
    let a.d = 3;
    (func1(),func2(),*a)
}

let (*x,*y,*z) = p();
let (*m,*n) = (func1(),func2());

print(m.a);
print(m.b);
print(m.c);
print(n.a);
print(x.a);
print(x.c);
print(y.b);
print(y.c);
print(z.d);

>> xunbundle

>> test

test anon regression

>> input

procedure proc1() {
    let a.a = 0;
    (*a,1)
}

let (*b,c) = proc1();

>> xunbundle

>> test

test anon regression2

>> input

procedure print(a) { 0 }

function func1() {
    let a.a = 0;
    *a
}

let *b = func1();
print(b.z);

>> xunbundle
