>> test

bad variable 1

>> input

procedure p(x) { (y) }

p(0);

>> linearize-fail trim

unknown variable 'y' at test:2

>> test

bad variable 2

>> input

procedure p(x) { (y) }

p(x);

>> linearize-fail trim

unknown variable 'x' at test:4

>> test

bad variable 3

>> input

let y = x;

>> linearize-fail trim

unknown variable 'x' at test:2

>> test

bad variable 4

>> input

procedure p(x) { (*y) }

p(0);

>> linearize-fail trim

empty bundle return 'y' at test:2

>> test

bad variable 5

>> input

procedure p(*x) { (*x) }

p(*a);

>> linearize-fail trim

empty bundle argument 'a' at test:4

>> test

bad variable 6

>> input

procedure p(x) { (x) }

let **a = p(**b);

>> linearize-fail trim

empty bundle used in repeater 'b' at test:4

>> test

bad args 1

>> input

procedure p() { 0 }

p(0);

>> linearize-fail trim

definition at test:2 has 0 args; call passes 1 at test:4

>> test

bad args 2

>> input

procedure p(x) { 0 }

p();

>> linearize-fail trim

definition at test:2 has 1 args; call passes 0 at test:4

>> test

bad args 3

>> input

function f(s) { 0 }
procedure p() { 0 }

p(f(0,1));

>> linearize-fail trim

definition at test:2 has 1 args; call passes 2 at test:5

>> test

bad args 4

>> input

function f(s) { 0 }
procedure p() { f(0,1,2) }

p();

>> linearize-fail trim

definition at test:2 has 1 args; call passes 3 at test:3

>> test

bad ret 1

>> input

procedure p() { (1,2) }

let x = p();

>> linearize-fail trim

definition at test:2 has 2 return values; call expects 1 at test:4

>> test

bad ret 2

>> input

procedure p() { (1,2) }

let (x,y,z) = p();

>> linearize-fail trim

definition at test:2 has 2 return values; call expects 3 at test:4

>> test

bad ret counter 1

>> input

procedure p() { (1,2) }

p();

>> linearize trim

test:2 1 <constant> 1
test:2 2 <constant> 2

