>> test

Function parsing smoke

>> input

export function first(a: seq(?X)) -> ?X {
    print("getting first element");
    entry(a,0)
}

>> parse strip

[
    PTStatement {
        value: FuncDef(PTFuncDef{
            name: "first",
            modifiers: [Export],
            args: [
                Normal(TypedArgument{
                    id:"a",
                    typespec:ArgTypeSpec{
                        arg_types: [
                            SequenceWildcard("X")
                        ],
                        checks:[]
                    }
                })
            ],
            captures: [],
            block: [
                PTStatement {
                    value: BareCall(PTCall{
                        name: "print",
                        args: [
                            Normal(Constant(String("gettingfirstelement")))
                        ],
                        is_macro: false
                    }),
                    file: ["test"],
                    line_no: 3,
                    context: 1
                }
            ],
            value: Normal(Call(PTCall{
                name: "entry",
                args: [
                    Normal(Variable(Variable{prefix:None,name:"a"})),
                    Normal(Constant(Number(0.0)))
                ],
                is_macro: false
            })),
            value_type: Some(ArgTypeSpec{arg_types:[Wildcard("X")],checks:[]})
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Christmas tree argument specs function

>> input

function test(a: seq(number)|number|boolean length(?X) ref(?Y), b: seq(?Z)) -> seq(?Z) ref(?X) {
    42
}

>> parse strip

[
    PTStatement {
        value: FuncDef(PTFuncDef{
            name: "test",
            modifiers: [],
            args: [
                Normal(TypedArgument{
                    id: "a",
                    typespec:ArgTypeSpec{
                        arg_types: [
                            Sequence(Number),
                            Atomic(Number),
                            Atomic(Boolean)
                        ],
                        checks: [
                            Check{check_type:Length,name:"X"},
                            Check{check_type:Reference,name:"Y"}
                        ]
                    }
                }),
                Normal(TypedArgument{
                    id: "b",
                    typespec:ArgTypeSpec{
                        arg_types: [
                            SequenceWildcard("Z")
                        ],
                        checks: [
                        ]
                    }
                })
            ],
            captures: [],
            block: [],
            value: Normal(Constant(Number(42.0))),
            value_type: Some(ArgTypeSpec{
                arg_types:[SequenceWildcard("Z")],
                checks: [Check{check_type:Reference,name:"X"}]
            })
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Empty functions not allowed

>> input

function test(a: seq(number)|number|boolean length(?X) ref(?Y), b: seq(?Z)) -> seq(?Z) ref(?X) {
}

>> parse-fail strip

expected function_value, capture_decl, or inner_block

>> test

Functions, no types.

>> input

function inc(a) {
    a+1
}

>> parse strip

[
    PTStatement {
        value: FuncDef(PTFuncDef{
            name: "inc",
            modifiers: [],
            args: [
                Normal(TypedArgument{
                    id:"a",
                    typespec:ArgTypeSpec{
                        arg_types:[],checks:[]
                    }
                })
            ],
            captures: [],
            block: [],
            value: Normal(Infix(Variable(Variable{prefix:None,name:"a"}),"+",Constant(Number(1.0)))),
            value_type: None
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Functions, no return.

>> input

function more(a: number length(?X)) {
    3
}

>> parse strip

[
    PTStatement {
        value: FuncDef(PTFuncDef{
            name: "more",
            modifiers: [],
            args: [
                Normal(TypedArgument{
                    id: "a",
                    typespec:ArgTypeSpec{
                        arg_types: [Atomic(Number)],
                        checks: [Check{check_type:Length,name:"X"}]
                    }
                })
            ],
            captures: [],
            block: [],
            value: Normal(Constant(Number(3.0))),
            value_type: None
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Functions, bundle pass and return.

>> input

function func(*x) {
    inc(x.a);
    *x
}

>> parse strip

[
    PTStatement {
        value: FuncDef(PTFuncDef{
            name: "func",
            modifiers: [],
            args: [Bundle("x")],
            captures: [],
            block: [
                PTStatement {
                    value: BareCall(PTCall{
                        name: "inc",
                        args: [Normal(Variable(Variable{prefix:Some("x"),name:"a"}))],
                        is_macro:false
                    }),
                    file: ["test"],
                    line_no: 3,
                    context: 1
                }
            ],
            value: Bundle("x"),
            value_type: None
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Functions, no args.

>> input

function x() { 42 }

>> parse strip

[
    PTStatement {
        value: FuncDef(PTFuncDef{
            name: "x",
            modifiers: [],
            args: [],
            captures: [],
            block: [],
            value: Normal(Constant(Number(42.0))),
            value_type: None
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Procedures, multi return

>> input

procedure x(a: number, b: number) -> (number,number) {
    print(a);
    print(b);
    (b,a)
}

>> parse strip

[
    PTStatement {
        value: ProcDef(PTProcDef{
            name: "x",
            modifiers: [],
            args: [
                Normal(TypedArgument{
                    id:"a",
                    typespec:ArgTypeSpec{
                        arg_types:[Atomic(Number)],
                        checks:[]
                    }
                }),
                Normal(TypedArgument{
                    id:"b",
                    typespec:ArgTypeSpec{
                        arg_types:[Atomic(Number)],
                        checks:[]
                    }
                })
            ],
            captures: [],
            block:[
                PTStatement{
                    value:BareCall(PTCall{name:"print",args:[Normal(Variable(Variable{prefix:None,name:"a"}))],is_macro:false}),
                    file:["test"],
                    line_no:3,
                    context:1
                },
                PTStatement{
                    value:BareCall(PTCall{name:"print",args:[Normal(Variable(Variable{prefix:None,name:"b"}))],is_macro:false}),
                    file:["test"],
                    line_no:4,
                    context:1
                }
            ],
            ret: [
                Normal(Variable(Variable{prefix:None,name:"b"})),
                Normal(Variable(Variable{prefix:None,name:"a"}))
            ],
            ret_type: Some([
                ArgTypeSpec{arg_types:[Atomic(Number)],checks:[]},
                ArgTypeSpec{arg_types:[Atomic(Number)],checks:[]}
            ])
        }),
        file:["test"],
        line_no:2,
        context:1
    }
]

>> test

Functions, no multi return

>> input

function x(a: number, b: number) -> (number,number) {
    a+b
}

>> parse-fail strip

expected arg_type or arg_check

>> test

Procedures, single return, bracketed.

>> input

procedure x(a: number, b: number) -> (number) {
    (a+b)
}

>> parse strip

[
    PTStatement {
        value: ProcDef(PTProcDef{
            name: "x",
            modifiers: [],
            args: [
                Normal(TypedArgument{
                    id:"a",
                    typespec:ArgTypeSpec{
                        arg_types:[Atomic(Number)],
                        checks:[]
                    }
                }),
                Normal(TypedArgument{
                    id:"b",
                    typespec:ArgTypeSpec{
                        arg_types:[Atomic(Number)],
                        checks:[]
                        }
                })
            ],
            captures: [],
            block: [],
            ret: [
                Normal(Infix(Variable(Variable{prefix:None,name:"a"}),"+",Variable(Variable{prefix:None,name:"b"})))
            ],
            ret_type: Some([ArgTypeSpec{arg_types:[Atomic(Number)],checks:[]}])
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Procedures, single return, unbracketed.

>> input

procedure x(a: number, b: number) -> number {
    a+b
}

>> parse strip

[
    PTStatement {
        value: ProcDef(PTProcDef{
            name: "x",
            modifiers: [],
            args: [
                Normal(TypedArgument{
                    id:"a",
                    typespec:ArgTypeSpec{
                        arg_types:[Atomic(Number)],
                        checks:[]
                    }
                }),
                Normal(TypedArgument{
                    id:"b",
                    typespec:ArgTypeSpec{
                        arg_types:[Atomic(Number)],
                        checks:[]
                    }
                })
            ],
            captures: [],
            block: [],
            ret: [
                Normal(Infix(Variable(Variable{prefix:None,name:"a"}),"+",Variable(Variable{prefix:None,name:"b"})))
            ],
            ret_type: Some([ArgTypeSpec{arg_types:[Atomic(Number)],checks:[]}])
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Procedures, empty allowed.

>> input

procedure x(a: number, b: number) {
}

>> parse strip

[
    PTStatement {
        value: ProcDef(PTProcDef{
            name: "x",
            modifiers: [],
            args: [
                Normal(TypedArgument{
                    id:"a",
                    typespec:ArgTypeSpec{
                        arg_types:[Atomic(Number)],
                        checks:[]
                    }
                }),
                Normal(TypedArgument{
                    id:"b",
                    typespec:ArgTypeSpec{
                        arg_types:[Atomic(Number)],
                        checks:[]
                    }
                })
            ],
            captures: [],
            block: [],
            ret: [],
            ret_type: None
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Procedures, no types but checks

>> input

procedure x(a, b: length(?X...)) {
}

>> parse strip

[
    PTStatement {
        value: ProcDef(PTProcDef{
            name: "x",
            modifiers: [],
            args: [
                Normal(TypedArgument{
                    id:"a",
                    typespec:ArgTypeSpec{
                        arg_types:[],
                        checks:[]
                    }
                }),
                Normal(TypedArgument{
                    id:"b",
                    typespec:ArgTypeSpec{
                        arg_types:[],
                        checks:[
                            Check{check_type:LengthOrInfinite,name:"X"}
                        ]
                    }
                })
            ],
            captures: [],
            block: [],
            ret: [],
            ret_type: None
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Regression

>> input

funcion func(*x) -> *x {
    inc(x.a);
    *x
}

>> parse-fail strip

expected EOI or block

>> test

Procedures, no return

>> input

procedure x(a, b: length(?X...), *c) {
    c.x = 1;
}

>> parse strip

[
    PTStatement {
        value: ProcDef(PTProcDef{
            name:"x",
            modifiers:[],
            args:[
                Normal(TypedArgument{
                    id:"a",
                    typespec:ArgTypeSpec{
                        arg_types:[],
                        checks:[]
                    }
                }),
                Normal(TypedArgument{
                    id:"b",
                    typespec:ArgTypeSpec{
                        arg_types:[],
                        checks:[Check{check_type:LengthOrInfinite,name:"X"}]
                    }
                }),
                Bundle("c")
            ],
            captures: [],
            block:[
                PTStatement{
                    value:ModifyStatement(
                        [Variable{prefix:Some("c"),name:"x"}],
                        [Constant(Number(1.0))]
                    ),
                    file:["test"],
                    line_no:3,
                    context:1
                }
            ],
            ret: [],
            ret_type:None
        }),
        file:["test"],
        line_no:2,
        context:1
    }
]

>> test

Captures

>> input

let x = 2;
let y = 20;

procedure test(a) {
    capture x,y;

    x+y+1
}

>> parse strip

[
    PTStatement{
        value:LetStatement(
            [Normal((Variable{prefix:None,name:"x"},[]))],
            [Normal(Constant(Number(2.0)))]
        ),
        file:["test"],
        line_no:2,
        context:1
    },
    PTStatement{
        value:LetStatement(
            [Normal((Variable{prefix:None,name:"y"},[]))],
            [Normal(Constant(Number(20.0)))]
        ),
        file:["test"],
        line_no:3,
        context:1
    },
    PTStatement{
        value:ProcDef(PTProcDef{
            name:"test",
            modifiers:[],
            args:[
                Normal(TypedArgument{id:"a",typespec:ArgTypeSpec{arg_types:[],checks:[]}})
            ],
            captures:[
                Normal(Variable{prefix:None,name:"x"}),
                Normal(Variable{prefix:None,name:"y"})
            ],
            block:[],
            ret:[
                Normal(
                    Infix(
                        Infix(
                            Variable(Variable{prefix:None,name:"x"}),
                            "+",
                            Variable(Variable{prefix:None,name:"y"})
                        ),
                        "+",
                        Constant(Number(1.0))
                    )
                )
            ],
            ret_type:None
        }),
        file:["test"],
        line_no:5,
        context:1
    }
]

>> test

Procedures, bundle return

>> input

procedure x(a, b: length(?X...), *c) {
    c.x = 1;
    *c
}

>> parse strip

[
    PTStatement {
        value: ProcDef(PTProcDef{
            name: "x",
            modifiers: [],
            args: [
                Normal(TypedArgument{
                    id:"a",
                    typespec:ArgTypeSpec{
                        arg_types:[],
                        checks:[]
                    }
                }),
                Normal(TypedArgument{
                    id:"b",
                    typespec:ArgTypeSpec{
                        arg_types:[],
                        checks:[
                            Check{check_type:LengthOrInfinite,name:"X"}
                        ]
                    }
                }),
                Bundle("c")
            ],
            captures: [],
            block: [
                PTStatement {
                    value: ModifyStatement(
                        [Variable{prefix:Some("c"),name:"x"}],
                        [Constant(Number(1.0))]
                    ),
                    file: ["test"],
                    line_no: 3,
                    context: 1
                }
            ],
            ret: [Bundle("c")],
            ret_type: None
        }),
        file: ["test"],
        line_no: 2,
        context: 1
    }
]

>> test

Procedure return (let)

>> input

let (x : length(w) total(ww),y,z) = c(a,b,c);

>> parse strip

[
    PTStatement{
        value: LetStatement([
            Normal((
                Variable{prefix:None,name:"x"},[
                    Check{check_type:Length,name:"w"},
                    Check{check_type:Sum,name:"ww"}
                ]
            )),
            Normal((
                Variable{prefix:None,name:"y"},[]
            )),
            Normal((
                Variable{prefix:None,name:"z"},[]
            ))
        ],
        [
            Normal(Call(PTCall{
                name:"c",
                args:[
                    Normal(Variable(Variable{prefix:None,name:"a"})),
                    Normal(Variable(Variable{prefix:None,name:"b"})),
                    Normal(Variable(Variable{prefix:None,name:"c"}))
                ],
                is_macro:false
            }))
        ]
    ),
    file:["test"],
    line_no:2,
    context:1
    }
]

>> test

Procedure return (modify)

>> input

(x,y,z) = c(a,b,c);

>> parse strip

[
    PTStatement{value:ModifyStatement(
        [
            Variable{prefix:None,name:"x"},
            Variable{prefix:None,name:"y"},
            Variable{prefix:None,name:"z"}
        ],[
            Call(PTCall{
                name: "c",
                args:[
                    Normal(Variable(Variable{prefix:None,name:"a"})),
                    Normal(Variable(Variable{prefix:None,name:"b"})),
                    Normal(Variable(Variable{prefix:None,name:"c"}))
                ],
                is_macro:false
            })
        ]
    ),
    file:["test"],
    line_no:2,
    context:1}
]
